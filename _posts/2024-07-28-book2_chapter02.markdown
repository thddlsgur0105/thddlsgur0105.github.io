---
layout: post
title:  "Chapter 02. 훈련 세트와 테스트 세트"
date:   2024-07-28 21:14:31 +0900
categories: ML Session
toc: true
pin: true
---

# 훈련 세트와 테스트 세트

## 지도 학습과 비지도 학습
* **지도 학습 알고리즘은 입력(데이터)과 타깃(정답)으로 이뤄진 훈련 데이터가 필요합니다.**
* 입력으로 사용된 길이와 무게를 **특성**이라고 합니다.
* 비지도 학습 알고리즘은 타깃(정답) 없이 입력 데이터만 사용합니다.

* 비지도 학습은 타깃 데이터가 없다. 따라서 무엇을 예측하는 것이 아니라 어떤 특징을 찾는 데 주로 활용한다.

## 훈련 세트와 테스트 세트
* 평가에 사용하는 데이터를 **테스트 세트**, 훈련에 사용되는 데이터를 **훈련 세트**라고 부릅니다.

* 훈련 세트는 모델을 훈련할 때 사용하는 데이터로, 보통 훈련 세트가 클수록 좋다. 따라서 테스트 세트를 제외한 모든 데이터를 사용한다.

* 테스트 세트는 전체 데이터에서 20~30%를 테스트 세트로 사용하는 경우가 많다. 전체 데이터가 아주 크다면 1%만 덜어내도 충분할 수 있다.

## 샘플링 편향
* 일반적으로 훈련 세트와 테스트 세트에 샘플이 골고루 섞여 있지 않으면 샘플링이 한 쪽으로 치우쳤다는 의미로 **샘플링 편향**이라고 부른다.
* 특정 종류의 샘플이 과도하게 많은 샘플링 편향을 가지고 있다면 제대로 된 지도 학습 모델을 만들 수 없다.

## 넘파이
* 파이썬의 대표적인 배열 라이브러리
* 고차원의 배열을 손쉽게 만들고 조작할 수 있는 간편한 도구를 많이 제공
* 배열 인덱싱: 1개의 인덱스가 아닌 여러 개의 인덱스로 한 번에 여러 개의 원소를 선택할 수 있다.

### 핵심 패키지와 함수
* seed(): 넘파이에서 난수를 생성하기 위한 정수 초깃값을 지정한다. 초깃값이 같으면 동일한 난수를 뽑을 수 있다. 따라서 랜덤 함수의 결과를 동일하게 재현하고 싶을 때 사용한다.

* arange(): 일정한 간격의 정수 또는 실수 배열을 만든다. 기본 간격은 1이다. 매개변수가 하나이면 종료 숫자를 의미한다. 0에서 종료 숫자까지의 배열을 만들고, 종료 숫자는 배열에 포함되지 않는다.

* shuffle(): 주어진 배열을 랜덤하게 섞는다. 다차원 배열의 경우 첫 번째 축(행)에 대해서 섞는다.

## 두 번째 머신러닝 프로그램
* predict() 메서드가 반환하는 값은 단순한 파이썬 리스트가 아니라 넘파이 배열이다.

## 확인 문제
1. 1
2. 4
3. 2

# 데이터 전처리

## 넘파이로 데이터 준비하기
* 튜플(tuple): 리스트와 매우 비슷하다. 리스트처럼 원소에 순서는 있지만 한 번 만들어진 튜플은 수정이 불가능하다.
* 튜플을 사용하면 함수로 전달한 값이 바뀌지 않는다는 것을 믿을 수 있기 때문에 매개변수 값으로 많이 사용한다.
* 데이터가 클수록 파이썬 리스트는 비효율적이므로 넘파이 배열을 사용하는 게 좋다.

### 사이킷런으로 훈련 세트와 테스트 세트 나누기
* train_test_split(): 이 함수는 전달되는 리스트나 배열을 비율에 맞게 훈련 세트와 테스트 세트로 나누어 준다. 물론 나누기 전에 알아서 섞어준다.
* train_test_split() 함수에도 자체적으로 랜덤 시드를 지정할 수 있는 random_State 매개변수가 있다.
* 이 함수는 기본적으로 25%를 테스트 세트로 떼어낸다.

#### 무작위로 데이터를 나누었을 때 샘플이 골고루 섞이지 않는 경우
* 특히 일부 클래스의 개수가 적을 때 이런 일이 생길 수 있다.
* 훈련 세트와 테스트 세트에 샘플의 클래스 비율이 일정하지 않다면 모델이 일부 샘플을 올바르게 학습할 수 없을 것이다.
* train_test_split() 함수의 stratify 매개변수에 타깃 데이터를 전달하면 클래스 비율에 맞게 데이터를 나눈다.
* 훈련 데이터가 작거나 특정 클래스의 샘플 개수가 적을 때 특히 유용하다.

## 수상한 도미 한 마리

## 기준을 맞춰라
* 두 특성의 **스케일**이 다르다 == 두 특성(길이와 무게)의 값이 놓인 범위가 다르다.
* 알고리즘이 특히 거리 기반일 경우, 특성 데이터를 표현하는 기준이 다르면 올바르게 예측할 수 없다.
* 이런 알고리즘들은 샘플 간의 거리에 영향을 많이 받으므로 제대로 사용하려면 특성값을 일정한 기준으로 맞춰 주어야 하는데, 이러한 작업을 **데이터 전처리**라고 부른다.

### 표준점수(z 점수)
* 가장 널리 사용하는 전처리 방법 중 하나
* 표준점수는 각 특성값이 0에서 표준편차의 몇 배만큼 떨어져 있는지를 나타낸다.
* 이를 통해 실제 특성값의 크기와 상관없이 동일한 조건으로 비교할 수 있다.

## 전처리 데이터로 모델 훈련하기
* 표준점수로 변환하는 전처리과정을 거친 후 새로운 입력 데이터에 대해서 산점도상에 표시하려는 경우에는, **훈련 세트의 mean, std를 이용해서 변환해야 한다.**

## 스케일이 다른 특성 처리

## 마무리
* 브로드캐스팅: 크기가 다른 넘파이 배열에서 자동으로 사칙 연산을 모든 행이나 열로 확장하여 수행하는 기능이다.

### scikit-learn
* train_test_split(): 훈련 데이터를 훈련 세트와 테스트 세트로 나누는 함수이다. 테스트 세트로 나눌 비율은 test_size 매개변수에서 지정할 수 있으며 기본값은 0.25(25%)이다.
* 위 함수는 shuffle 매개변수로 훈련 세트와 테스트 세트로 나누기 전에 무작위로 섞을 지 여부를 결정할 수 있다. stratify 매개변수에 클래스 레이블이 담긴 배열(일반적으로 타깃 데이터)을 전달하면 클래스 비율에 맞게 훈련 세트와 테스트 세트를 나눈다.

## 확인 문제
1. 3
2. 1